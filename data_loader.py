# data_loader.py

import pandas as pd
import os
import glob

def load_feature_data(
    features_path,
    include_augmentations=True,
    include_speed_torque=True,
    binary_classification=False,
    domains_to_include=None,
    features_to_include=None
):
    """
    Loads and processes feature data from CSV files with a high degree of flexibility.

    Args:
        features_path (str): The path to the 'features' folder generated by your MATLAB script.
        include_augmentations (bool): If False, only files with 'original' in the name are loaded.
        include_speed_torque (bool): If False, 'Speed' and 'Torque' columns are dropped.
        binary_classification (bool): If True, all labels other than 'healthy' are converted to 'damaged'.
        domains_to_include (list of str, optional): A list of domains to keep (e.g., ['time', 'frequency']).
                                                    If None, all domains are kept.
        features_to_include (list of str, optional): A specific list of feature columns to keep.
                                                     If None, all feature columns are kept.

    Returns:
        pandas.DataFrame: A DataFrame containing the processed data.
    """
    # Find all CSV files in the specified path
    all_files = glob.glob(os.path.join(features_path, '*.csv'))
    
    if not all_files:
        print(f"Warning: No CSV files found in '{features_path}'. Please check the path.")
        return pd.DataFrame()

    # --- 1. Filter files based on augmentation ---
    if not include_augmentations:
        # Keep only files that contain the 'original' keyword
        files_to_load = [f for f in all_files if '_original_' in os.path.basename(f)]
    else:
        files_to_load = all_files

    # --- 2. Load and concatenate data ---
    df_list = [pd.read_csv(f) for f in files_to_load]
    if not df_list:
        print("Warning: No files matched the loading criteria (e.g., 'original' files not found).")
        return pd.DataFrame()
        
    df = pd.concat(df_list, ignore_index=True)
    #print(f"Successfully loaded {len(files_to_load)} files into a DataFrame with shape {df.shape}")

    # --- 3. Apply binary classification mapping ---
    if binary_classification:
        df['Label'] = df['Label'].apply(lambda x: 'healthy' if x == 'healthy' else 'damaged')
        print("Applied binary classification: 'healthy' vs 'damaged'.")

    # --- 4. Select columns based on domains and features ---
    cols_to_keep = ['Label', 'Speed', 'Torque']
    all_feature_cols = [col for col in df.columns if col not in ['Label', 'Speed', 'Torque']]

    if features_to_include:
        # If a specific feature list is given, use it
        selected_features = [f for f in features_to_include if f in all_feature_cols]
        cols_to_keep.extend(selected_features)
        print(f"Selected specific features: {selected_features}")
    elif domains_to_include:
        # If domains are specified, find features that belong to them
        selected_features = []
        for domain in domains_to_include:
            if domain == 'time':
                selected_features.extend([f for f in all_feature_cols if not ('spectral_' in f or 'Wavelet' in f or 'Spectrogram' in f)])
            elif domain == 'frequency':
                selected_features.extend([f for f in all_feature_cols if 'spectral_' in f or 'Freq' in f or 'bandwidth' in f])
            elif domain == 'time-frequency':
                 selected_features.extend([f for f in all_feature_cols if 'Wavelet' in f or 'Spectrogram' in f])
        
        cols_to_keep.extend(list(set(selected_features)))
        print(f"Selected domains: {domains_to_include}")
    else:
        # Keep all features
        cols_to_keep.extend(all_feature_cols)

    df = df[cols_to_keep]

    # --- 5. Include or exclude Speed and Torque ---
    if not include_speed_torque:
        # Use a try-except block in case they are already gone
        try:
            df = df.drop(columns=['Speed', 'Torque'])
            print("Dropped 'Speed' and 'Torque' columns.")
        except KeyError:
            pass # Columns were not present, which is fine.

    #print(f"Final DataFrame shape: {df.shape}")
    return df


# --- Configuration for this analysis ---
# Path to your features folder from the MATLAB experiment
"""
FEATURES_DIR = r'H:\Extracted_Features\SIZA\SIZA_highpass_all_features\features'


# --- EXAMPLE 1 : Load everything for initial exploration ---
print("--- Loading Example 1: All Data ---")
df_full = load_feature_data(
    features_path=FEATURES_DIR,
    include_augmentations=True,
    include_speed_torque=True,
    binary_classification=False
)
print("\nFull DataFrame head:")
display(df_full.head())
print("\nLabel distribution:")
print(df_full['Label'].value_counts())


# --- EXAMPLE 2: Binary classification, no augmentations, only time-domain features ---
print("\n\n--- Loading Example 2: Binary Classification, Time-Domain Only ---")
df_binary_time = load_feature_data(
    features_path=FEATURES_DIR,
    include_augmentations=False,      # Only 'original' data
    include_speed_torque=False,       # Drop operating conditions
    binary_classification=True,       # 'healthy' vs 'damaged'
    domains_to_include=['time']       # Only time-domain features
)
print("\nBinary Time-Domain DataFrame head:")
display(df_binary_time.head())
print("\nLabel distribution:")
print(df_binary_time['Label'].value_counts())


# --- EXAMPLE 3: Specific feature selection for a targeted model ---
print("\n\n--- Loading Example 3: Specific Feature Selection ---")
df_specific = load_feature_data(
    features_path=FEATURES_DIR,
    include_augmentations=False,
    include_speed_torque=True,
    binary_classification=False,
    features_to_include=['rms', 'kurtosis', 'meanFreq'] # Select only these three features
)
print("\nSpecific Features DataFrame head:")
display(df_specific.head())
"""